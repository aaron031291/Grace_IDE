// Grace Syntax Highlighting System
// Advanced multi-language syntax highlighting for Grace IDE

class SyntaxHighlighter {
    constructor(config = {}) {
        // Configuration
        this.config = {
            theme: config.theme || 'grace-dark',
            tabSize: config.tabSize || 4,
            showLineNumbers: config.showLineNumbers !== false,
            showInvisibles: config.showInvisibles || false,
            highlightActiveLine: config.highlightActiveLine !== false,
            highlightMatchingBrackets: config.highlightMatchingBrackets !== false,
            enableLiveHighlighting: config.enableLiveHighlighting !== false,
            maxHighlightLength: config.maxHighlightLength || 100000, // 100KB limit for performance
            ...config
        };
        
        // State
        this.state = {
            initialized: false,
            activeLanguage: null,
            activeTheme: this.config.theme,
            cache: new Map(),
            workers: new Map()
        };
        
        // Language definitions
        this.languages = new Map();
        this.themes = new Map();
        
        // Token types
        this.tokenTypes = {
            KEYWORD: 'keyword',
            IDENTIFIER: 'identifier',
            STRING: 'string',
            NUMBER: 'number',
            COMMENT: 'comment',
            OPERATOR: 'operator',
            PUNCTUATION: 'punctuation',
            FUNCTION: 'function',
            CLASS: 'class',
            VARIABLE: 'variable',
            CONSTANT: 'constant',
            PROPERTY: 'property',
            TAG: 'tag',
            ATTRIBUTE: 'attribute',
            BUILTIN: 'builtin',
            REGEX: 'regex',
            TEMPLATE: 'template',
            DECORATOR: 'decorator',
            ERROR: 'error'
        };
        
        // Initialize
        this.initialize();
    }
    
    // Initialization
    initialize() {
        console.log('üé® Initializing Grace Syntax Highlighter...');
        
        try {
            // Register built-in languages
            this.registerBuiltInLanguages();
            
            // Register built-in themes
            this.registerBuiltInThemes();
            
            // Setup worker for background highlighting
            if (typeof Worker !== 'undefined' && this.config.enableLiveHighlighting) {
                this.setupHighlightingWorker();
            }
            
            // Inject styles
            this.injectStyles();
            
            // Connect to Grace Core
            this.connectToGraceCore();
            
            this.state.initialized = true;
            console.log('‚úÖ Syntax Highlighter initialized');
        } catch (error) {
            console.error('‚ùå Failed to initialize Syntax Highlighter:', error);
        }
    }
    
    // Language Registration
    registerBuiltInLanguages() {
        // JavaScript
        this.registerLanguage('javascript', {
            name: 'JavaScript',
            extensions: ['.js', '.jsx', '.mjs', '.ts', '.tsx'],
            keywords: [
                'async', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue',
                'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends',
                'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'let',
                'new', 'of', 'return', 'static', 'super', 'switch', 'this', 'throw',
                'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'interface',
                'type', 'namespace', 'module', 'declare', 'readonly', 'public', 'private',
                'protected', 'abstract', 'implements', 'enum'
            ],
            builtins: [
                'Array', 'Object', 'String', 'Number', 'Boolean', 'Date', 'Math', 'JSON',
                'Promise', 'Symbol', 'Map', 'Set', 'WeakMap', 'WeakSet', 'Proxy',
                'Reflect', 'console', 'window', 'document', 'global', 'process',
                'Buffer', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval'
            ],
            operators: [
                '=', '+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=',
                '&=', '|=', '^=', '&&=', '||=', '??=', '==', '!=', '===', '!==',
                '<', '>', '<=', '>=', '<<', '>>', '>>>', '+', '-', '*', '/', '%',
                '**', '++', '--', '&&', '||', '!', '~', '&', '|', '^', '?', ':',
                '=>', '...', '??', '?.', '?:'
            ],
            stringDelimiters: ['"', "'", '`'],
            commentDelimiters: {
                single: '//',
                multi: ['/*', '*/']
            },
            patterns: {
                number: /^\d+(\.\d+)?([eE][+-]?\d+)?/,
                identifier: /^[a-zA-Z_$][a-zA-Z0-9_$]*/,
                regex: /^\/(?:[^\/\\]|\\.)+\/[gimuy]*/
            }
        });
        
        // Python
        this.registerLanguage('python', {
            name: 'Python',
            extensions: ['.py', '.pyw', '.pyi'],
            keywords: [
                'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue',
                'def', 'del', 'elif', 'else', 'except', 'False', 'finally', 'for',
                'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
                'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True', 'try',
                'while', 'with', 'yield'
            ],
            builtins: [
                'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytes', 'callable',
                'chr', 'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir',
                'divmod', 'enumerate', 'eval', 'exec', 'filter', 'float', 'format',
                'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex',
                'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len',
                'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object',
                'oct', 'open', 'ord', 'pow', 'print', 'property', 'range', 'repr',
                'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod',
                'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip', '__import__'
            ],
            operators: [
                '=', '+=', '-=', '*=', '/=', '//=', '%=', '**=', '&=', '|=', '^=',
                '>>=', '<<=', '==', '!=', '<', '>', '<=', '>=', '+', '-', '*', '/',
                '//', '%', '**', '~', '&', '|', '^', '>>', '<<'
            ],
            stringDelimiters: ['"', "'", '"""', "'''"],
            commentDelimiters: {
                single: '#'
            },
            patterns: {
                number: /^\d+(\.\d+)?([eE][+-]?\d+)?/,
                identifier: /^[a-zA-Z_][a-zA-Z0-9_]*/,
                decorator: /^@[a-zA-Z_][a-zA-Z0-9_.]*/
            }
        });
        
        // HTML
        this.registerLanguage('html', {
            name: 'HTML',
            extensions: ['.html', '.htm', '.xhtml', '.vue', '.svelte'],
            tagNames: [
                'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base',
                'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption',
                'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del',
                'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset',
                'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',
                'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img',
                'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map',
                'mark', 'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol',
                'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress',
                'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select',
                'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup',
                'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',
                'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'
            ],
            attributeNames: [
                'accept', 'action', 'alt', 'async', 'autocomplete', 'autofocus', 'autoplay',
                'charset', 'checked', 'class', 'cols', 'colspan', 'content', 'contenteditable',
                'controls', 'coords', 'data', 'datetime', 'defer', 'dir', 'disabled',
                'download', 'draggable', 'enctype', 'for', 'form', 'headers', 'height',
                'hidden', 'href', 'id', 'lang', 'list', 'loop', 'max', 'maxlength', 'media',
                'method', 'min', 'multiple', 'muted', 'name', 'novalidate', 'open',
                'pattern', 'placeholder', 'poster', 'preload', 'readonly', 'rel', 'required',
                'rows', 'rowspan', 'sandbox', 'scope', 'selected', 'shape', 'size', 'sizes',
                'span', 'spellcheck', 'src', 'srcdoc', 'srcset', 'start', 'step', 'style',
                'tabindex', 'target', 'title', 'type', 'usemap', 'value', 'width', 'wrap'
            ]
        });
        
        // CSS
        this.registerLanguage('css', {
            name: 'CSS',
            extensions: ['.css', '.scss', '.sass', '.less', '.stylus'],
            keywords: [
                '@import', '@media', '@charset', '@font-face', '@namespace', '@supports',
                '@keyframes', '@page', '@viewport', '@counter-style', '@document',
                'important', 'and', 'or', 'not', 'only'
            ],
            properties: [
                'align-content', 'align-items', 'align-self', 'animation', 'background',
                'border', 'border-radius', 'bottom', 'box-shadow', 'box-sizing', 'color',
                'content', 'cursor', 'display', 'flex', 'flex-direction', 'flex-wrap',
                'float', 'font', 'font-family', 'font-size', 'font-weight', 'height',
                'justify-content', 'left', 'line-height', 'margin', 'max-height',
                'max-width', 'min-height', 'min-width', 'opacity', 'overflow', 'padding',
                'position', 'right', 'text-align', 'text-decoration', 'text-transform',
                'top', 'transform', 'transition', 'vertical-align', 'visibility', 'width',
                'z-index', 'grid', 'grid-template', 'gap'
            ],
            values: [
                'absolute', 'auto', 'block', 'bold', 'border-box', 'center', 'fixed',
                'flex', 'hidden', 'inherit', 'inline', 'inline-block', 'italic', 'left',
                'none', 'normal', 'nowrap', 'pointer', 'relative', 'right', 'solid',
                'transparent', 'underline', 'visible', 'grid', 'inline-grid'
            ],
            patterns: {
                color: /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b/,
                unit: /^\d+(\.\d+)?(px|em|rem|%|vh|vw|pt|pc|in|cm|mm|ex|ch|vmin|vmax)/,
                function: /^[a-zA-Z-]+\(/
            }
        });
        
        // JSON
        this.registerLanguage('json', {
            name: 'JSON',
            extensions: ['.json', '.jsonc', '.json5'],
            constants: ['true', 'false', 'null'],
            patterns: {
                number: /^-?\d+(\.\d+)?([eE][+-]?\d+)?/,
                string: /^"([^"\\]|\\.)*"/
            }
        });
        
        // Markdown
        this.registerLanguage('markdown', {
            name: 'Markdown',
            extensions: ['.md', '.markdown', '.mdown', '.mkd'],
            markers: {
                heading: /^#{1,6}\s/,
                bold: /\*\*([^*]+)\*\*/g,
                italic: /\*([^*]+)\*/g,
                code: /`([^`]+)`/g,
                codeBlock: /^```(\w+)?\n([\s\S]*?)^```/gm,
                link: /\[([^\]]+)\]\(([^)]+)\)/g,
                image: /!\[([^\]]*)\]\(([^)]+)\)/g,
                list: /^[\s]*[-*+]\s/,
                orderedList: /^[\s]*\d+\.\s/,
                blockquote: /^>\s/,
                horizontalRule: /^(---|\*\*\*|___)\s*$/
            }
        });
        
        // XML
        this.registerLanguage('xml', {
            name: 'XML',
            extensions: ['.xml', '.xsl', '.xsd', '.wsdl', '.rss', '.atom'],
            patterns: {
                tag: /<\/?[a-zA-Z][\w-]*(?:\s+[^>]*)?\/?>/,
                attribute: /\s+([a-zA-Z][\w-]*)=/,
                cdata: /<!\[CDATA\[[\s\S]*?\]\]>/
            }
        });
        
        // SQL
        this.registerLanguage('sql', {
            name: 'SQL',
            extensions: ['.sql'],
            keywords: [
                'SELECT', 'FROM', 'WHERE', 'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER',
                'GROUP', 'BY', 'ORDER', 'HAVING', 'UNION', 'INSERT', 'UPDATE', 'DELETE',
                'CREATE', 'ALTER', 'DROP', 'TABLE', 'INDEX', 'VIEW', 'DATABASE',
                'SCHEMA', 'PROCEDURE', 'FUNCTION', 'TRIGGER', 'CONSTRAINT', 'PRIMARY',
                'FOREIGN', 'KEY', 'REFERENCES', 'NOT', 'NULL', 'DEFAULT', 'AUTO_INCREMENT',
                'UNIQUE', 'CHECK', 'AND', 'OR', 'IN', 'EXISTS', 'BETWEEN', 'LIKE',
                'IS', 'AS', 'DISTINCT', 'ALL', 'ANY', 'SOME', 'CASE', 'WHEN', 'THEN',
                'ELSE', 'END', 'IF', 'WHILE', 'FOR', 'LOOP', 'BEGIN', 'COMMIT', 'ROLLBACK'
            ],
            types: [
                'VARCHAR', 'CHAR', 'TEXT', 'INT', 'INTEGER', 'BIGINT', 'SMALLINT',
                'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE', 'REAL', 'DATE', 'TIME',
                'DATETIME', 'TIMESTAMP', 'YEAR', 'BOOLEAN', 'BOOL', 'BINARY', 'BLOB'
            ]
        });
    }
    
    registerLanguage(id, definition) {
        this.languages.set(id, {
            id: id,
            ...definition
        });
    }
    
    // Theme Registration
    registerBuiltInThemes() {
        // Grace Dark Theme
        this.registerTheme('grace-dark', {
            name: 'Grace Dark',
            colors: {
                background: '#0a0b1e',
                foreground: '#ffffff',
                lineNumber: '#5a5b6e',
                activeLine: '#1a1b2e',
                selection: '#2a2b3e',
                cursor: '#00d4ff',
                
                // Token colors
                keyword: '#ff79c6',
                identifier: '#f8f8f2',
                string: '#f1fa8c',
                number: '#bd93f9',
                comment: '#6272a4',
                operator: '#ff79c6',
                punctuation: '#f8f8f2',
                function: '#50fa7b',
                class: '#8be9fd',
                variable: '#f8f8f2',
                constant: '#bd93f9',
                property: '#8be9fd',
                tag: '#ff79c6',
                attribute: '#50fa7b',
                builtin: '#8be9fd',
                regex: '#ff5555',
                template: '#f1fa8c',
                decorator: '#ffb86c',
                error: '#ff5555',
                
                // Special
                strong: '#ffb86c',
                emphasis: '#f1fa8c'
            }
        });
        
        // Grace Light Theme
        this.registerTheme('grace-light', {
            name: 'Grace Light',
            colors: {
                background: '#ffffff',
                foreground: '#000000',
                lineNumber: '#999999',
                activeLine: '#f5f5f5',
                selection: '#e0e0e0',
                cursor: '#0066cc',
                
                keyword: '#d73a49',
                identifier: '#24292e',
                string: '#032f62',
                number: '#005cc5',
                comment: '#6a737d',
                operator: '#d73a49',
                punctuation: '#24292e',
                function: '#6f42c1',
                class: '#e36209',
                variable: '#24292e',
                constant: '#005cc5',
                property: '#005cc5',
                tag: '#22863a',
                attribute: '#6f42c1',
                builtin: '#e36209',
                regex: '#d73a49',
                template: '#032f62',
                decorator: '#6f42c1',
                error: '#d73a49'
            }
        });
        
        // Grace Matrix Theme
        this.registerTheme('grace-matrix', {
            name: 'Grace Matrix',
            colors: {
                background: '#000000',
                foreground: '#00ff00',
                lineNumber: '#008800',
                activeLine: '#001100',
                selection: '#003300',
                cursor: '#00ff00',
                
                keyword: '#00ff00',
                identifier: '#00cc00',
                string: '#00ff88',
                number: '#88ff00',
                comment: '#008800',
                operator: '#00ff00',
                punctuation: '#00cc00',
                function: '#00ffcc',
                class: '#ccff00',
                variable: '#00cc00',
                constant: '#88ff00',
                property: '#00ffcc',
                tag: '#00ff00',
                attribute: '#00ffcc',
                builtin: '#ccff00',
                regex: '#ffff00',
                template: '#00ff88',
                decorator: '#00ccff',
                error: '#ff0000'
            }
        });
        
        // Grace Ocean Theme
        this.registerTheme('grace-ocean', {
            name: 'Grace Ocean',
            colors: {
                background: '#0f111a',
                foreground: '#a7adba',
                lineNumber: '#4f5b66',
                activeLine: '#1b2232',
                selection: '#343d46',
                cursor: '#6699cc',
                
                keyword: '#c594c5',
                identifier: '#a7adba',
                string: '#99c794',
                number: '#f99157',
                comment: '#65737e',
                operator: '#c594c5',
                punctuation: '#a7adba',
                function: '#6699cc',
                class: '#fac863',
                variable: '#a7adba',
                constant: '#f99157',
                property: '#6699cc',
                tag: '#ec5f67',
                attribute: '#fac863',
                builtin: '#6699cc',
                regex: '#ec5f67',
                template: '#99c794',
                decorator: '#fac863',
                error: '#ec5f67'
            }
        });
    }
    
    registerTheme(id, definition) {
        this.themes.set(id, {
            id: id,
            ...definition
        });
    }
    
    // Highlighting Methods
    async highlight(text, languageId, options = {}) {
        try {
            // Validate input
            if (typeof text !== 'string') {
                throw new Error('Text must be a string');
            }
            
            // Check cache first
            const cacheKey = `${languageId}:${this.hashString(text)}:${this.state.activeTheme}`;
            if (this.state.cache.has(cacheKey) && !options.noCache) {
                return this.state.cache.get(cacheKey);
            }
            
            // Check text size limit
            if (text.length > this.config.maxHighlightLength) {
                console.warn('Text too long for highlighting, returning plain text');
                return this.createPlainTextResult(text);
            }
            
            // Get language definition
            const language = this.languages.get(languageId);
            if (!language) {
                console.warn(`Language ${languageId} not found`);
                return this.createPlainTextResult(text);
            }
            
            // Tokenize
            const tokens = this.tokenize(text, language);
            
            // Apply theme
            const themed = this.applyTheme(tokens, this.state.activeTheme);
            
            // Create HTML
            const html = this.createHighlightedHTML(themed, options);
            
            // Cache result
            const result = {
                html: html,
                tokens: tokens,
                language: languageId,
                theme: this.state.activeTheme
            };
            
            this.state.cache.set(cacheKey, result);
            
            // Limit cache size
            if (this.state.cache.size > 1000) {
                const firstKey = this.state.cache.keys().next().value;
                this.state.cache.delete(firstKey);
            }
            
            return result;
        } catch (error) {
            console.error('Error highlighting text:', error);
            return this.createPlainTextResult(text);
        }
    }
    
    // Simple but robust tokenizer
    tokenize(text, language) {
        const tokens = [];
        const lines = text.split('\n');
        
        lines.forEach((line, lineIndex) => {
            let position = 0;
            
            while (position < line.length) {
                let matched = false;
                
                // Skip whitespace
                const whitespaceMatch = /^\s+/.exec(line.substring(position));
                if (whitespaceMatch) {
                    position += whitespaceMatch[0].length;
                    continue;
                }
                
                // Check for multi-line comments (simplified)
                if (language.commentDelimiters && language.commentDelimiters.multi) {
                    const [start, end] = language.commentDelimiters.multi;
                    if (line.substring(position, position + start.length) === start) {
                        let endPos = line.indexOf(end, position + start.length);
                        if (endPos === -1) endPos = line.length;
                        else endPos += end.length;
                        
                        tokens.push({
                            type: 'comment',
                            value: line.substring(position, endPos),
                            line: lineIndex,
                            start: position,
                            end: endPos
                        });
                        position = endPos;
                        matched = true;
                        continue;
                    }
                }
                
                // Check for single-line comments
                if (language.commentDelimiters && language.commentDelimiters.single) {
                    if (line.substring(position, position + language.commentDelimiters.single.length) === language.commentDelimiters.single) {
                        tokens.push({
                            type: 'comment',
                            value: line.substring(position),
                            line: lineIndex,
                            start: position,
                            end: line.length
                        });
                        position = line.length;
                        matched = true;
                        continue;
                    }
                }
                
                // Check for strings
                if (language.stringDelimiters) {
                    for (const delimiter of language.stringDelimiters) {
                        if (line.substring(position, position + delimiter.length) === delimiter) {
                            let endPos = position + delimiter.length;
                            let escaped = false;
                            
                            while (endPos < line.length) {
                                if (escaped) {
                                    escaped = false;
                                } else if (line[endPos] === '\\') {
                                    escaped = true;
                                } else if (line.substring(endPos, endPos + delimiter.length) === delimiter) {
                                    endPos += delimiter.length;
                                    break;
                                }
                                endPos++;
                            }
                            
                            tokens.push({
                                type: 'string',
                                value: line.substring(position, endPos),
                                line: lineIndex,
                                start: position,
                                end: endPos
                            });
                            position = endPos;
                            matched = true;
                            break;
                        }
                    }
                }
                
                if (matched) continue;
                
                // Check for regex patterns
                if (language.patterns) {
                    for (const [patternName, pattern] of Object.entries(language.patterns)) {
                        const match = pattern.exec(line.substring(position));
                        if (match && match.index === 0) {
                            const tokenType = patternName === 'identifier' ? 
                                this.classifyIdentifier(match[0], language) : patternName;
                            
                            tokens.push({
                                type: tokenType,
                                value: match[0],
                                line: lineIndex,
                                start: position,
                                end: position + match[0].length
                            });
                            position += match[0].length;
                            matched = true;
                            break;
                        }
                    }
                }
                
                if (matched) continue;
                
                // Check for numbers
                const numberMatch = /^\d+(\.\d+)?([eE][+-]?\d+)?/.exec(line.substring(position));
                if (numberMatch) {
                    tokens.push({
                        type: 'number',
                        value: numberMatch[0],
                        line: lineIndex,
                        start: position,
                        end: position + numberMatch[0].length
                    });
                    position += numberMatch[0].length;
                    matched = true;
                    continue;
                }
                
                // Check for identifiers and keywords
                const wordMatch = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(line.substring(position));
                if (wordMatch) {
                    const word = wordMatch[0];
                    const type = this.classifyWord(word, language);
                    
                    tokens.push({
                        type: type,
                        value: word,
                        line: lineIndex,
                        start: position,
                        end: position + word.length
                    });
                    position += word.length;
                    matched = true;
                    continue;
                }
                
                // Check for operators
                if (language.operators) {
                    const remaining = line.substring(position);
                    const sortedOps = language.operators.sort((a, b) => b.length - a.length);
                    
                    for (const op of sortedOps) {
                        if (remaining.startsWith(op)) {
                            tokens.push({
                                type: 'operator',
                                value: op,
                                line: lineIndex,
                                start: position,
                                end: position + op.length
                            });
                            position += op.length;
                            matched = true;
                            break;
                        }
                    }
                }
                
                if (matched) continue;
                
                // Default: treat as punctuation
                tokens.push({
                    type: 'punctuation',
                    value: line[position],
                    line: lineIndex,
                    start: position,
                    end: position + 1
                });
                position++;
            }
        });
        
        return tokens;
    }
    
    classifyWord(word, language) {
        if (language.keywords && language.keywords.includes(word)) {
            return 'keyword';
        }
        if (language.builtins && language.builtins.includes(word)) {
            return 'builtin';
        }
        if (language.constants && language.constants.includes(word)) {
            return 'constant';
        }
        if (language.types && language.types.includes(word)) {
            return 'type';
        }
        return 'identifier';
    }
    
    classifyIdentifier(identifier, language) {
        return this.classifyWord(identifier, language);
    }
    
    applyTheme(tokens, themeId) {
        const theme = this.themes.get(themeId);
        if (!theme) {
            console.warn(`Theme ${themeId} not found`);
            return tokens;
        }
        
        return tokens.map(token => ({
            ...token,
            color: theme.colors[token.type] || theme.colors.foreground,
            style: this.getTokenStyle(token.type, theme)
        }));
    }
    
    getTokenStyle(type, theme) {
        const style = {
            color: theme.colors[type] || theme.colors.foreground
        };
        
        // Add special styles for certain token types
        switch (type) {
            case 'keyword':
                style.fontWeight = 'bold';
                break;
            case 'comment':
                style.fontStyle = 'italic';
                style.opacity = '0.8';
                break;
            case 'string':
                break;
            case 'error':
                style.textDecoration = 'underline';
                style.textDecorationColor = theme.colors.error;
                style.textDecorationStyle = 'wavy';
                break;
            case 'function':
                style.fontWeight = '500';
                break;
            case 'class':
                style.fontWeight = 'bold';
                break;
        }
        
        return style;
    }
    
    createHighlightedHTML(tokens, options) {
        const lines = this.groupTokensByLine(tokens);
        const showLineNumbers = options.showLineNumbers ?? this.config.showLineNumbers;
        const theme = this.themes.get(this.state.activeTheme);
        
        let html = '<div class="grace-code-container"';
        if (showLineNumbers) {
            html += ' data-line-numbers="true"';
        }
        html += ' style="background-color: ' + theme.colors.background + '; color: ' + theme.colors.foreground + ';">';
        
        if (showLineNumbers) {
            html += '<div class="grace-line-numbers" style="color: ' + theme.colors.lineNumber + ';">';
            for (let i = 1; i <= Math.max(1, lines.length); i++) {
                html += `<div class="grace-line-number">${i}</div>`;
            }
            html += '</div>';
        }
        
        html += '<div class="grace-code-content">';
        
        if (lines.length === 0) {
            html += '<div class="grace-code-line" data-line="1">&nbsp;</div>';
        } else {
            lines.forEach((lineTokens, lineIndex) => {
                html += `<div class="grace-code-line" data-line="${lineIndex + 1}">`;
                
                if (lineTokens.length === 0) {
                    html += '&nbsp;';
                } else {
                    lineTokens.forEach(token => {
                        const style = this.styleToString(token.style);
                        const className = `grace-token grace-token-${token.type}`;
                        html += `<span class="${className}" style="${style}">${
                            this.escapeHtml(token.value)
                        }</span>`;
                    });
                }
                
                html += '</div>';
            });
        }
        
        html += '</div></div>';
        
        return html;
    }
    
    groupTokensByLine(tokens) {
        const lines = [];
        let maxLine = 0;
        
        // Find max line number
        tokens.forEach(token => {
            if (token.line > maxLine) maxLine = token.line;
        });
        
        // Initialize lines array
        for (let i = 0; i <= maxLine; i++) {
            lines[i] = [];
        }
        
        // Group tokens by line
        tokens.forEach(token => {
            lines[token.line].push(token);
        });
        
        return lines;
    }
    
    styleToString(style) {
        return Object.entries(style)
            .map(([key, value]) => {
                const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
                return `${cssKey}: ${value}`;
            })
            .join('; ');
    }
    
    createPlainTextResult(text) {
        const lines = text.split('\n');
        const html = lines.map((line, i) => 
            `<div class="grace-code-line" data-line="${i + 1}">${this.escapeHtml(line) || '&nbsp;'}</div>`
        ).join('');
        
        return {
            html: `<div class="grace-code-container"><div class="grace-code-content">${html}</div></div>`,
            tokens: [],
            language: 'plain'
        };
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString(36);
    }
    
    // Live Highlighting
    setupLiveHighlighter(element, languageId, options = {}) {
        if (!element) {
            throw new Error('Element is required for live highlighting');
        }
        
        const highlighter = {
            element: element,
            language: languageId,
            options: options,
            timeout: null,
            enabled: true
        };
        
        // Input handler with debouncing
        const handleInput = () => {
            if (!highlighter.enabled) return;
            
            if (highlighter.timeout) {
                clearTimeout(highlighter.timeout);
            }
            
            highlighter.timeout = setTimeout(async () => {
                try {
                    const text = element.textContent || element.value || '';
                    const result = await this.highlight(text, languageId, options);
                    
                    if (element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
                        this.updateHighlightOverlay(element, result.html);
                    } else {
                        this.updateContentEditable(element, result.html);
                    }
                } catch (error) {
                    console.error('Error in live highlighting:', error);
                }
            }, 150); // 150ms debounce
        };
        
        // Add event listeners
        element.addEventListener('input', handleInput);
        element.addEventListener('scroll', () => {
            if (element._highlightOverlay) {
                element._highlightOverlay.scrollTop = element.scrollTop;
                element._highlightOverlay.scrollLeft = element.scrollLeft;
            }
        });
        
        element._highlighter = highlighter;
        
        // Initial highlight
        handleInput();
        
        return highlighter;
    }
    
    updateHighlightOverlay(element, html) {
        let overlay = element._highlightOverlay;
        
        if (!overlay) {
            overlay = this.createHighlightOverlay(element);
        }
        
        overlay.innerHTML = html;
        
        // Sync scroll position
        overlay.scrollTop = element.scrollTop;
        overlay.scrollLeft = element.scrollLeft;
    }
    
    createHighlightOverlay(element) {
        const overlay = document.createElement('div');
        overlay.className = 'grace-highlight-overlay';
        
        // Position overlay
        const rect = element.getBoundingClientRect();
        overlay.style.cssText = `
            position: absolute;
            top: ${rect.top + window.scrollY}px;
            left: ${rect.left + window.scrollX}px;
            width: ${rect.width}px;
            height: ${rect.height}px;
            pointer-events: none;
            white-space: pre-wrap;
            overflow: hidden;
            z-index: 1;
            background: transparent;
        `;
        
        // Copy computed styles
        const computedStyle = window.getComputedStyle(element);
        ['font-family', 'font-size', 'line-height', 'padding', 'border', 'box-sizing'].forEach(prop => {
            overlay.style[prop] = computedStyle[prop];
        });
        
        document.body.appendChild(overlay);
        element._highlightOverlay = overlay;
        
        // Make element text transparent but keep caret visible
        element.style.color = 'transparent';
        const theme = this.themes.get(this.state.activeTheme);
        element.style.caretColor = theme.colors.cursor;
        
        return overlay;
    }
    
    updateContentEditable(element, html) {
        // Save cursor position
        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
        let startOffset = 0;
        let startContainer = null;
        
        if (range) {
            startOffset = range.startOffset;
            startContainer = range.startContainer;
        }
        
        // Update content
        element.innerHTML = html;
        
        // Restore cursor position (simplified)
        if (range && element.firstChild) {
            try {
                const newRange = document.createRange();
                const textNode = this.findTextNodeAtOffset(element, startOffset);
                if (textNode) {
                    newRange.setStart(textNode.node, Math.min(textNode.offset, textNode.node.textContent.length));
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            } catch (e) {
                // Cursor restoration failed, position at end
                const newRange = document.createRange();
                newRange.selectNodeContents(element);
                newRange.collapse(false);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
        }
    }
    
    findTextNodeAtOffset(element, targetOffset) {
        let currentOffset = 0;
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let node;
        while (node = walker.nextNode()) {
            const nodeLength = node.textContent.length;
            if (currentOffset + nodeLength >= targetOffset) {
                return {
                    node: node,
                    offset: targetOffset - currentOffset
                };
            }
            currentOffset += nodeLength;
        }
        
        return null;
    }
    
    // Worker Setup
    setupHighlightingWorker() {
        try {
            const workerCode = `
                let languages = new Map();
                let tokenizers = new Map();
                
                self.onmessage = function(e) {
                    const { id, command, data } = e.data;
                    
                    try {
                        switch (command) {
                            case 'tokenize':
                                const tokens = tokenize(data.text, data.language);
                                self.postMessage({ id, result: tokens });
                                break;
                            case 'registerLanguage':
                                languages.set(data.id, data.definition);
                                self.postMessage({ id, result: 'ok' });
                                break;
                            default:
                                self.postMessage({ id, error: 'Unknown command: ' + command });
                        }
                    } catch (error) {
                        self.postMessage({ id, error: error.message });
                    }
                };
                
                function tokenize(text, languageId) {
                    // Simplified tokenization for worker
                    const tokens = [];
                    const lines = text.split('\\n');
                    
                    lines.forEach((line, lineIndex) => {
                        const words = line.split(/\\s+/);
                        let position = 0;
                        
                        words.forEach(word => {
                            if (word) {
                                tokens.push({
                                    type: 'identifier',
                                    value: word,
                                    line: lineIndex,
                                    start: position,
                                    end: position + word.length
                                });
                            }
                            position += word.length + 1;
                        });
                    });
                    
                    return tokens;
                }
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            
            const worker = new Worker(workerUrl);
            this.state.workers.set('main', worker);
            
            worker.onerror = (error) => {
                console.error('Worker error:', error);
            };
            
            URL.revokeObjectURL(workerUrl);
        } catch (error) {
            console.warn('Could not create highlighting worker:', error);
        }
    }
    
    // Style Injection
    injectStyles() {
        const styleId = 'grace-syntax-highlighter-styles';
        
        if (document.getElementById(styleId)) {
            return;
        }
        
        const styles = document.createElement('style');
        styles.id = styleId;
        styles.textContent = `
            /* Grace Syntax Highlighter Styles */
            .grace-code-container {
                font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Menlo', 'Consolas', monospace;
                font-size: 14px;
                line-height: 1.6;
                border-radius: 8px;
                overflow: auto;
                position: relative;
                display: flex;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .grace-code-container[data-line-numbers="true"] {
                padding-left: 0;
            }
            
            .grace-line-numbers {
                user-select: none;
                padding: 16px 12px 16px 16px;
                text-align: right;
                border-right: 1px solid rgba(255, 255, 255, 0.1);
                background: rgba(0, 0, 0, 0.2);
                min-width: 50px;
                flex-shrink: 0;
            }
            
            .grace-line-number {
                font-size: 12px;
                line-height: 1.6em;
                opacity: 0.6;
                height: 1.6em;
                display: flex;
                align-items: center;
                justify-content: flex-end;
            }
            
            .grace-code-content {
                flex: 1;
                padding: 16px;
                overflow-x: auto;
                min-width: 0;
            }
            
            .grace-code-line {
                white-space: pre;
                position: relative;
                min-height: 1.6em;
                line-height: 1.6em;
            }
            
            .grace-code-line:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            
            .grace-code-line.active {
                background: rgba(255, 255, 255, 0.1);
            }
            
            /* Token styles */
            .grace-token {
                transition: opacity 0.2s ease;
                position: relative;
            }
            
            .grace-token:hover {
                opacity: 0.8;
            }
            
            .grace-token-keyword {
                font-weight: 600;
            }
            
            .grace-token-comment {
                font-style: italic;
                opacity: 0.75;
            }
            
            .grace-token-string {
                position: relative;
            }
            
            .grace-token-function {
                font-weight: 500;
            }
            
            .grace-token-class {
                font-weight: 600;
            }
            
            .grace-token-error {
                position: relative;
            }
            
            .grace-token-error::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 2px;
                background: repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    currentColor 2px,
                    currentColor 4px
                );
                opacity: 0.6;
            }
            
            /* Selection */
            .grace-code-container ::selection {
                background: rgba(100, 149, 237, 0.3);
                color: inherit;
            }
            
            /* Highlight overlay for textareas */
            .grace-highlight-overlay {
                background: transparent;
                font-family: inherit;
                pointer-events: none;
                border: none;
                outline: none;
                resize: none;
                overflow: hidden;
            }
            
            .grace-highlight-overlay .grace-code-container {
                border: none;
                margin: 0;
                padding: 0;
                background: transparent;
            }
            
            /* Scrollbar styling */
            .grace-code-container::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            .grace-code-container::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }
            
            .grace-code-container::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }
            
            .grace-code-container::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
            
            /* Responsive design */
            @media (max-width: 768px) {
                .grace-code-container {
                    font-size: 12px;
                }
                
                .grace-code-content {
                    padding: 12px;
                }
                
                .grace-line-numbers {
                    padding: 12px 8px 12px 12px;
                    min-width: 40px;
                }
                
                .grace-line-number {
                    font-size: 11px;
                }
            }
        `;
        
        document.head.appendChild(styles);
    }
    
    // Language Detection
    detectLanguage(text, filename) {
        // Try by filename extension first
        if (filename) {
            const ext = '.' + filename.split('.').pop().toLowerCase();
            for (const [id, lang] of this.languages) {
                if (lang.extensions && lang.extensions.includes(ext)) {
                    return id;
                }
            }
        }
        
        // Content-based detection
        const detectors = [
            {
                language: 'html',
                patterns: [/<!DOCTYPE\s+html/i, /<html\b/i, /<\/html>/i, /<head\b/i, /<body\b/i]
            },
            {
                language: 'xml',
                patterns: [/<\?xml\b/i, /<\/\w+>/]
            },
            {
                language: 'json',
                patterns: [/^\s*[\{\[]/, /"\s*:\s*/, /,\s*"[\w-]+"\s*:/]
            },
            {
                language: 'css',
                patterns: [/\{[^}]*\}/, /[\w-]+\s*:\s*[^;]+;/, /@media\b/, /@import\b/]
            },
            {
                language: 'javascript',
                patterns: [
                    /\b(function|const|let|var|class|import|export)\b/,
                    /=>\s*[\{\w]/, /\.\w+\(/, /console\.\w+/
                ]
            },
            {
                language: 'python',
                patterns: [
                    /\bdef\s+\w+\s*\(/, /\bclass\s+\w+/, /\bimport\s+\w+/, /\bfrom\s+\w+\s+import/,
                    /:\s*$/, /^\s*#/, /\bprint\s*\(/
                ]
            },
            {
                language: 'sql',
                patterns: [
                    /\b(SELECT|FROM|WHERE|JOIN|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\b/i
                ]
            },
            {
                language: 'markdown',
                patterns: [/^#+\s/, /\*\*[^*]+\*\*/, /\[[^\]]+\]\([^)]+\)/, /^>\s/, /^[-*+]\s/]
            }
        ];
        
        for (const detector of detectors) {
            if (detector.patterns.some(pattern => pattern.test(text))) {
                return detector.language;
            }
        }
        
        return 'plain';
    }
    
    // Theme Management
    setTheme(themeId) {
        if (!this.themes.has(themeId)) {
            console.warn(`Theme ${themeId} not found`);
            return false;
        }
        
        const oldTheme = this.state.activeTheme;
        this.state.activeTheme = themeId;
        
        // Clear cache to force re-highlighting with new theme
        this.state.cache.clear();
        
        // Update CSS custom properties if they exist
        const theme = this.themes.get(themeId);
        if (theme && document.documentElement) {
            const root = document.documentElement;
            Object.entries(theme.colors).forEach(([key, value]) => {
                root.style.setProperty(`--grace-color-${key}`, value);
            });
        }
        
        // Re-highlight all highlighted elements
        document.querySelectorAll('[data-grace-highlighted]').forEach(async (element) => {
            const language = element.getAttribute('data-grace-language');
            const text = element.getAttribute('data-grace-text') || element.textContent;
            
            if (language && text) {
                try {
                    const result = await this.highlight(text, language);
                    element.innerHTML = result.html;
                } catch (error) {
                    console.error('Error re-highlighting element:', error);
                }
            }
        });
        
        console.log(`Theme changed from ${oldTheme} to ${themeId}`);
        return true;
    }
    
    // Utility Methods
    getSupportedLanguages() {
        return Array.from(this.languages.values()).map(lang => ({
            id: lang.id,
            name: lang.name,
            extensions: lang.extensions || []
        }));
    }
    
    getSupportedThemes() {
        return Array.from(this.themes.values()).map(theme => ({
            id: theme.id,
            name: theme.name
        }));
    }
    
    clearCache() {
        this.state.cache.clear();
        console.log('Syntax highlighter cache cleared');
    }
    
    getStats() {
        return {
            initialized: this.state.initialized,
            activeTheme: this.state.activeTheme,
            cacheSize: this.state.cache.size,
            languageCount: this.languages.size,
            themeCount: this.themes.size,
            workersActive: this.state.workers.size
        };
    }
    
    // Grace Core Integration
    connectToGraceCore() {
        if (typeof window !== 'undefined' && window.graceCore) {
            try {
                // Register syntax highlighter module
                window.graceCore.registerModule('syntax_highlighter', {
                    name: 'syntax_highlighter',
                    version: '1.0.0',
                    description: 'Advanced syntax highlighting for Grace IDE',
                    
                    execute: async (command, params = {}) => {
                        switch (command) {
                            case 'highlight':
                                if (!params.text || !params.language) {
                                    throw new Error('Text and language are required for highlighting');
                                }
                                return await this.highlight(params.text, params.language, params.options);
                                
                            case 'detect':
                                if (!params.text) {
                                    throw new Error('Text is required for language detection');
                                }
                                return this.detectLanguage(params.text, params.filename);
                                
                            case 'setTheme':
                                if (!params.theme) {
                                    throw new Error('Theme ID is required');
                                }
                                return this.setTheme(params.theme);
                                
                            case 'getLanguages':
                                return this.getSupportedLanguages();
                                
                            case 'getThemes':
                                return this.getSupportedThemes();
                                
                            case 'clearCache':
                                this.clearCache();
                                return { success: true };
                                
                            case 'getStats':
                                return this.getStats();
                                
                            case 'setupLive':
                                if (!params.element || !params.language) {
                                    throw new Error('Element and language are required for live highlighting');
                                }
                                return this.setupLiveHighlighter(params.element, params.language, params.options);
                                
                            default:
                                throw new Error(`Unknown syntax highlighter command: ${command}`);
                        }
                    }
                });
                
                console.log('‚úÖ Syntax Highlighter connected to Grace Core');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to connect to Grace Core:', error);
                return false;
            }
        }
        
        return false;
    }
    
    // Cleanup
    destroy() {
        try {
            // Terminate workers
            this.state.workers.forEach(worker => {
                worker.terminate();
            });
            this.state.workers.clear();
            
            // Clear cache
            this.state.cache.clear();
            
            // Remove event listeners and overlays
            document.querySelectorAll('[data-grace-highlighted]').forEach(element => {
                if (element._highlighter) {
                    element.removeEventListener('input', element._highlighter.handleInput);
                    delete element._highlighter;
                }
                
                if (element._highlightOverlay) {
                    element._highlightOverlay.remove();
                    delete element._highlightOverlay;
                }
                
                // Restore original element styles
                element.style.color = '';
                element.style.caretColor = '';
            });
            
            // Remove injected styles
            const existingStyles = document.getElementById('grace-syntax-highlighter-styles');
            if (existingStyles) {
                existingStyles.remove();
            }
            
            // Disconnect from Grace Core
            if (window.graceCore && window.graceCore.unregisterModule) {
                window.graceCore.unregisterModule('syntax_highlighter');
            }
            
            this.state.initialized = false;
            console.log('‚úÖ Syntax Highlighter destroyed successfully');
        } catch (error) {
            console.error('‚ùå Error during Syntax Highlighter cleanup:', error);
        }
    }
}

// Export and auto-initialization
if (typeof module !== 'undefined' && module.exports) {
    // Node.js environment
    module.exports = SyntaxHighlighter;
} else if (typeof window !== 'undefined') {
    // Browser environment
    window.SyntaxHighlighter = SyntaxHighlighter;
    
    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            window.graceSyntaxHighlighter = new SyntaxHighlighter();
        });
    } else {
        // DOM already loaded
        window.graceSyntaxHighlighter = new SyntaxHighlighter();
    }
}

// Additional helper functions for external use
if (typeof window !== 'undefined') {
    window.highlightCode = async function(element, language, options = {}) {
        if (!window.graceSyntaxHighlighter) {
            window.graceSyntaxHighlighter = new SyntaxHighlighter();
        }
        
        const text = element.textContent || element.innerText || '';
        const result = await window.graceSyntaxHighlighter.highlight(text, language, options);
        
        element.innerHTML = result.html;
        element.setAttribute('data-grace-highlighted', 'true');
        element.setAttribute('data-grace-language', language);
        element.setAttribute('data-grace-text', text);
        
        return result;
    };
    
    window.detectLanguage = function(text, filename) {
        if (!window.graceSyntaxHighlighter) {
            window.graceSyntaxHighlighter = new SyntaxHighlighter();
        }
        
        return window.graceSyntaxHighlighter.detectLanguage(text, filename);
    };
}